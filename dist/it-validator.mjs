var z=Object.freeze({__proto__:null});const v=t=>{const e={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"},r=/[&<>"'/]/ig;return t.replace(r,i=>e[i])},q=t=>t.trim(),$=t=>!(!isNaN(t)||typeof t=="number"||t instanceof Number),b=t=>!(!isNaN(Date.parse(t))||t instanceof Date),A=t=>!(t instanceof Array),N=t=>!(t instanceof Object&&!(t instanceof Date)&&!(t instanceof Array)),x=t=>!(typeof t=="string"||t instanceof String),W=t=>!(typeof t=="boolean"||[0,1,"1","0","true","false"].includes(t)),h=(t,e)=>{if(!t)return!1;switch(t){case Boolean:return W(e)?"Boolean":!1;case Number:return $(e)?"Number":!1;case Date:return b(e)?"Date":!1;case Array:return A(e)?"Array":!1;case Object:return N(e)?"Object":!1;case String:return x(e)?"String":!1;default:return!1}},F=/\s/g,U=/^[a-zA-Z\s]+$/,V=/^[0-9a-zA-Z\s]+$/,_=/^[0-9a-zA-Z\s-_]+$/,B=/^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i,d=(t=null)=>(typeof t=="string"&&(t=t.replace(F,"").length?t:null),typeof t!="undefined"&&t!==null),R=(t=void 0)=>!t||typeof t!="string"?!0:!U.test(t),D=(t=void 0)=>!t||typeof t!="string"?!0:!V.test(t),I=(t=void 0)=>!t||typeof t!="string"?!0:!_.test(t),j=(t=void 0)=>!t||typeof t!="string"?!0:!B.test(t),w=(t,e=void 0)=>!t.length||!(t instanceof Array)?!0:!t.includes(e),O=(t,e=void 0)=>(e instanceof Date&&(e=e.toISOString()),!t.test(String(e))),S=(t,e,r=void 0)=>t===Number&&Number(r)>e||r.length>e,E=(t,e,r=void 0)=>t===Number&&Number(r)<e||r.length<e,M=(t,e,r=void 0)=>t.length!==2||!(t[0]in e)||e[t[0]]===t[1]&&!d(r),T=(t,e,r=void 0)=>t.length!==2||!(t[0]in e)||e[t[0]]!==t[1]&&!d(r),Z=(t,e,r=void 0)=>!d(r)&&t.some(i=>i in e&&d(e[i])),P=(t,e,r=void 0)=>!d(r)&&t.some(i=>!(i in e)||!d(e[i])),C=(t,e,r=void 0)=>!d(r)&&t.every(i=>!(i in e)&&!d(e[i])),a=(t,e,r)=>t?typeof t=="string"||typeof t!="object"?t:t[e]?t[e]:r:r,G=(t,e,r)=>{let i=t;return i||(i={}),i[e]=r,i},o=(t,e)=>t?e:()=>!1,H=async(t,e)=>{if(!e)return{err:null,value:void 0};if(!e.type)throw new Error(`${e.ruleName} must have a type property specified`);let r=t[e.ruleName];if(e.required&&!d(r))return{err:a(e.message,"required","is required"),value:r};if(e.ruleName in t&&t[e.ruleName]!==void 0){const i=h(e.type,r);if(i)return{err:a(e.message,"type",`value ${r} doesn't match the type ${i}`),value:r};if(o(!!e.min,E)(e.type,e.min,r))return{err:a(e.message,"min",`value ${r} has a min of ${e.min}`),value:r};if(o(!!e.max,S)(e.type,e.max,r))return{err:a(e.message,"max",`value ${r} has a max of ${e.max}`),value:r};if(o(e.alpha,R)(r))return{err:a(e.message,"alpha",`value ${r} must contain alphabetic characters only`),value:r};if(o(e.alphaNum,D)(r))return{err:a(e.message,"alphaNum",`value ${r} must contain alphanumeric characters only`),value:r};if(o(e.alphaDash,I)(r))return{err:a(e.message,"alphaDash",`value ${r} must contain alphanumeric characters, dashes or undescores only`),value:r};if(o(e.email,j)(r))return{err:a(e.message,"email",`value ${r} must be a valid email`),value:r};if(o(!!e.in,w)(e.in,r))return{err:a(e.message,"in",`value ${r} is not in ${e.in}`),value:r};if(o(!!e.regex,O)(e.regex,r))return{err:a(e.message,"regex",`value ${r} has not a valid format`),value:r}}if(e.validate){const i=await e.validate(r);if(i)return{err:a(e.message,"validate",`${i}`),value:r}}return o(!!e.requiredIf,M)(e.requiredIf,t,r)?{err:a(e.message,"requiredIf",`value ${r}, needs to be present if ${e.requiredIf[0]} is equal to ${e.requiredIf[1]}`),value:r}:o(!!e.requiredUnless,T)(e.requiredUnless,t,r)?{err:a(e.message,"requiredUnless",`value ${r}, needs to be present unless ${e.requiredWithout[0]} is equal to ${e.requiredWithout[1]}`),value:r}:o(!!e.requiredWith,Z)(e.requiredWith,t,r)?{err:a(e.message,"requiredWith",`value ${r}, needs to be present if any of [${e.requiredWith}] is present`),value:r}:o(!!e.requiredWithout,P)(e.requiredWithout,t,r)?{err:a(e.message,"requiredWithout",`value ${r}, needs to be present if one of [${e.requiredWithout}] is not present`),value:r}:o(!!e.requiredWithoutAll,C)(e.requiredWithoutAll,t,r)?{err:a(e.message,"requiredWithoutAll",`value ${r}, needs to be present if all of [${e.requiredWithoutAll}] is not present`),value:r}:!e.required&&e.defaultAfterValidate&&!d(r)?{err:null,value:e.defaultAfterValidate}:(r&&(e.clean&&((e.clean===!0||e.clean.trim)&&(r=q(r)),(e.clean===!0||e.clean.sanitize)&&(r=v(r))),h({...e,type:Number},r)&&!h({...e,type:String},r)&&(r=decodeURI(r))),{err:null,value:r})},p=async(t,e)=>{let r={},i={};for(let n in e){let u=t[n];const s=e[n];if(!s){s===null&&u!==void 0&&(r[n]=u,t[n]=u);continue}if(s.ruleName=n,!s.required&&s.default&&!d(u)){r[n]=s.default,t[n]=s.default;continue}let{err:c,value:f}=await H(t,s);if(c){i[n]=c;continue}if(f!==void 0){if(s.type===Array||s.type===Object){if(!s.children){r[n]=f,t[n]=f;continue}if(s.type===Array){const l=[],g={};for(const y in f){const m=await p(f[y],s.children);m.err?g[y]=m.err:l.push(m.values)}c=g,c&&(i[n]=c),f=l}else{const l=await p(f,s.children);c=l.err,c&&(i[n]=c),f=l.values}}!c&&f!==void 0&&(r[n]=f,t[n]=f)}}return{err:Object.keys(i).length?i:null,values:r}},J=async(t,e)=>{if(!t)return{err:{validatorFatal:"Need some fields to validate"},values:null};if(!e)return{err:{validatorFatal:"Need some rules to validate against"},values:null};try{const{err:r,values:i}=await(async(n,u)=>await p(n,u(n)))(t,e);return{err:r,values:i}}catch(r){return{err:{validatorFatal:r.message||r},values:null}}};export{z as Types,G as addError,d as hasValue,R as invalidAlpha,I as invalidAlphaDash,D as invalidAlphaNum,A as invalidArray,W as invalidBoolean,b as invalidDate,j as invalidEmail,w as invalidIn,S as invalidMax,E as invalidMin,$ as invalidNumber,N as invalidObject,O as invalidRegex,x as invalidString,h as invalidType,v as sanitize,q as trim,J as validate};
