var U=Object.freeze({__proto__:null});const q=t=>{const e={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"},r=/[&<>"'/]/ig;return t.replace(r,i=>e[i])},v=t=>t.trim(),$=t=>!(!isNaN(t)||typeof t=="number"||t instanceof Number),b=t=>!(!isNaN(Date.parse(t))||t instanceof Date),A=t=>!(t instanceof Array),N=t=>!(t instanceof Object&&!(t instanceof Date)&&!(t instanceof Array)),x=t=>!(typeof t=="string"||t instanceof String),W=t=>!(typeof t=="boolean"||[0,1,"1","0","true","false"].includes(t)),h=(t,e)=>{if(!t)return!1;switch(t){case Boolean:return W(e)?"Boolean":!1;case Number:return $(e)?"Number":!1;case Date:return b(e)?"Date":!1;case Array:return A(e)?"Array":!1;case Object:return N(e)?"Object":!1;case String:return x(e)?"String":!1;default:return!1}},V=/\s/g,_=/^[a-zA-Z\s]+$/,E=/^[0-9a-zA-Z\s]+$/,F=/^[0-9a-zA-Z\s-_]+$/,B=/^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i,d=(t=null)=>(typeof t=="string"&&(t=t.replace(V,"").length?t:null),typeof t!="undefined"&&t!==null),R=(t=void 0)=>!t||typeof t!="string"?!0:!_.test(t),D=(t=void 0)=>!t||typeof t!="string"?!0:!E.test(t),I=(t=void 0)=>!t||typeof t!="string"?!0:!F.test(t),j=(t=void 0)=>!t||typeof t!="string"?!0:!B.test(t),O=(t,e=void 0)=>!t.length||!(t instanceof Array)?!0:!t.includes(e),S=(t,e=void 0)=>(e instanceof Date&&(e=e.toISOString()),!t.test(String(e))),w=(t,e=void 0)=>typeof e=="number"&&Number(e)>t||e.length>t,z=(t,e=void 0)=>typeof e=="number"&&Number(e)<t||e.length<t,M=(t,e,r=void 0)=>t.length!==2||!(t[0]in e)||e[t[0]]===t[1]&&!d(r),T=(t,e,r=void 0)=>t.length!==2||!(t[0]in e)||e[t[0]]!==t[1]&&!d(r),Z=(t,e,r=void 0)=>!d(r)&&t.some(i=>i in e&&d(e[i])),P=(t,e,r=void 0)=>!d(r)&&t.some(i=>!(i in e)||!d(e[i])),C=(t,e,r=void 0)=>!d(r)&&t.every(i=>!(i in e)&&!d(e[i])),n=(t,e,r)=>t?typeof t=="string"||typeof t!="object"?t:t[e]?t[e]:r:r,o=(t,e)=>t?e:()=>!1,G=async(t,e)=>{if(!e)return{err:null,value:void 0};let r=t[e.ruleName];if(e.required&&!d(r))return{err:n(e.message,"required","is required"),value:r};if(e.ruleName in t){const i=h(e.type,r);if(i)return{err:n(e.message,"type",`value ${r} doesn't match the type ${i}`),value:r};if(o(!!e.min,z)(e.min,r))return{err:n(e.message,"min",`value ${r} has a min of ${e.min}`),value:r};if(o(!!e.max,w)(e.max,r))return{err:n(e.message,"max",`value ${r} has a max of ${e.max}`),value:r};if(o(e.alpha,R)(r))return{err:n(e.message,"alpha",`value ${r} must contain alphabetic characters only`),value:r};if(o(e.alphaNum,D)(r))return{err:n(e.message,"alphaNum",`value ${r} must contain alphanumeric characters only`),value:r};if(o(e.alphaDash,I)(r))return{err:n(e.message,"alphaDash",`value ${r} must contain alphanumeric characters, dashes or undescores only`),value:r};if(o(e.email,j)(r))return{err:n(e.message,"email",`value ${r} must be a valid email`),value:r};if(o(!!e.in,O)(e.in,r))return{err:n(e.message,"in",`value ${r} is not in ${e.in}`),value:r};if(o(!!e.regex,S)(e.regex,r))return{err:n(e.message,"regex",`value ${r} has not a valid format`),value:r}}if(e.validate){const i=await e.validate(r);if(i)return{err:n(e.message,"validate",`${i}`),value:r}}return o(!!e.requiredIf,M)(e.requiredIf,t,r)?{err:n(e.message,"requiredIf",`value ${r}, needs to be present if ${e.requiredIf[0]} is equal to ${e.requiredIf[1]}`),value:r}:o(!!e.requiredUnless,T)(e.requiredUnless,t,r)?{err:n(e.message,"requiredUnless",`value ${r}, needs to be present unless ${e.requiredWithout[0]} is equal to ${e.requiredWithout[1]}`),value:r}:o(!!e.requiredWith,Z)(e.requiredWith,t,r)?{err:n(e.message,"requiredWith",`value ${r}, needs to be present if any of [${e.requiredWith}] is present`),value:r}:o(!!e.requiredWithout,P)(e.requiredWithout,t,r)?{err:n(e.message,"requiredWithout",`value ${r}, needs to be present if one of [${e.requiredWithout}] is not present`),value:r}:o(!!e.requiredWithoutAll,C)(e.requiredWithoutAll,t,r)?{err:n(e.message,"requiredWithoutAll",`value ${r}, needs to be present if all of [${e.requiredWithoutAll}] is not present`),value:r}:!e.required&&e.defaultAfterValidate&&!d(r)?{err:null,value:e.defaultAfterValidate}:(r&&(e.clean&&((e.clean===!0||e.clean.trim)&&(r=v(r)),(e.clean===!0||e.clean.sanitize)&&(r=q(r))),h({...e,type:Number},r)&&!h({...e,type:String},r)&&(r=decodeURI(r))),{err:null,value:r})},p=async(t,e)=>{let r={},i={};for(let a in e){let l=t[a];const s=e[a];if(!s){s===null&&l!==void 0&&(r[a]=l,t[a]=l);continue}if(s.ruleName=a,!s.required&&s.default&&!d(l)){r[a]=s.default,t[a]=s.default;continue}let{err:c,value:f}=await G(t,s);if(c){i[a]=c;continue}if(f!==void 0){if(s.type===Array||s.type===Object){if(!s.children){r[a]=f,t[a]=f;continue}if(s.type===Array){const u=[],g={};for(const y in f){const m=await p(f[y],s.children);m.err?g[y]=m.err:u.push(m.values)}c=g,c&&(i[a]=c),f=u}else{const u=await p(f,s.children);c=u.err,c&&(i[a]=c),f=u.values}}!c&&f!==void 0&&(r[a]=f,t[a]=f)}}return{err:Object.keys(i).length?i:null,values:r}},H=async(t,e)=>t?e?await(async(r,i)=>await p(r,i(r)))(t,e):{err:{validatorFatal:"Need some rules to validate against"},values:null}:{err:{validatorFatal:"Need some fields to validate"},values:null};export{U as Types,d as hasValue,R as invalidAlpha,I as invalidAlphaDash,D as invalidAlphaNum,A as invalidArray,W as invalidBoolean,b as invalidDate,j as invalidEmail,O as invalidIn,w as invalidMax,z as invalidMin,$ as invalidNumber,N as invalidObject,S as invalidRegex,x as invalidString,h as invalidType,q as sanitize,v as trim,H as validate};
